#version 460 core
layout(local_size_x =    , local_size_y =    , local_size_z =    ) in;
layout(rgba32f, binding = 0) writeonly restrict uniform image2D imageOut;


layout(location = 2) uniform vec4  u_dt;
layout(location = 3) uniform int   u_samplesPpx;
layout(location = 4) uniform int   u_recurseDepth;


struct Ray
{
    vec3 origin;
    vec3 dir;
};
struct Sphere 
{ 
    vec4 pos_radius; 
};
struct CameraTransform
{
    vec3  position;
    vec2  viewport;
    float focal_length; /* Distance from camera origin to camera Screen */
    uint  reserved;
};


layout(std430, binding=1) buffer SceneData
{
    CameraTransform transform;
    uint            max_objects;
    uint            curr_length;
    uint            reserved[2];
    Sphere          objects[];
};


vec3 rayAt(in Ray ray, in float t) { return ray.origin + ray.dir * t; }
Ray  cameraGetRay(CameraTransform cam, vec3 rayOrigin, vec2 uv) /* Camera pointing towards -Z axis */
{
    vec3 rayDir;
    rayDir = cam.position - vec3( (vec2(0.5f) - uv) * cam.viewport, cam.focal_length);
    return Ray(rayOrigin, rayDir);
}





/* Using trascendenal constants for fun & profit */
const float c_infinity = 1. / 0.;
const float c_pi         = 3.14159265358979323846264338327950288;
const float c_sqrt2      = 1.41421356237309504880;
const float c_sqrt3      = 1.73205080756887729352;
const float c_phi        = 1.61803398874989484820;
const float c_ramanujan  = 262537412640768743.999999999999250073; /* e^( pi * sqrt(163) )*/
const float c_atan2      = 0.955316618124509278163;
const float c_chaitin    = 0.0078749969978123844;                 /* avg prob that a rand program will halt */
const float c_feigenbaum = 2.50290787509589282228;

float degrees_to_radians(float degrees) { return degrees * c_pi / 180.0f; }




uint pcg_hash(in uint x)
{
    x = x * 747796405u + 2891336453u;
    uint word = ((x >> ((x >> 28u) + 4u)) ^ x) * 277803737u;
    return (word >> 22u) ^ word;
}


float random( vec2 p )
{
    const vec2 r = vec2(23.1406926327792690, 2.6651441426902251);
    return fract( cos( mod( 123456789., 1e-7 + 256. * dot(p,r) ) ) );  
}


float uintToNormFloat(uint m) { 
    return uintBitsToFloat((m & 0x007FFFFFu) | 0x3F800000u ) - 1.0f; 
}


float random_norm(vec2 p) {
    return uintToNormFloat(floatBitsToUint(random(p)));
}


vec3 simpleRandUnitSphere(in vec2 texelCoord, uint sampleNum)
{
    vec3 r3 = vec3(
        random(  vec2(u_dt.x, random(texelCoord)       )),
        random(  vec2(u_dt.y, random(vec2(sampleNum))  )), 
        0
    );
    r3.z = random(r3.xy);
    return normalize(r3);
}




struct SphereRayIntersectionResult
{
    float t;
    vec3  normal;
};


void intersection(
    in  Ray    R, 
    in  Sphere S, 
    in  vec2   t_bounds, 
    out SphereRayIntersectionResult 
    result
) {
    float a, b, ac, discrim;
    vec3 tmp;
    vec2 coef;


    tmp = R.origin - S.pos_radius.xyz;
    b = -1.0f * dot(R.dir, tmp); /* calculate -b */
    a = dot(R.dir, R.dir);
    ac = dot(tmp, tmp) - S.pos_radius.w * S.pos_radius.w;

    b  *= (1.0f / a);
    ac *= (1.0f / a);
    discrim = b * b - ac;

    result.t = float(discrim < 0.0f) * c_infinity;
    if(isinf(result.t))
        return;


    coef = vec2(
        b + sqrt(discrim),
        b - sqrt(discrim)
    );
    coef = mix(vec2(c_infinity), coef, 
        bvec2(
            t_bounds.x < coef.x && coef.x < t_bounds.y,
            t_bounds.x < coef.y && coef.y < t_bounds.y
        )
    );
    result.t = min(coef.x, coef.y);
    if(isinf(result.t))
        return;


    result.normal  = rayAt(R, result.t) - S.pos_radius.xyz;
    result.normal *= (1.0f / S.pos_radius.w);
    result.normal *= mix(-1.0f, 1.0f, dot(R.dir, result.normal) < 0.0f); /* set proper direction if vector is outwards/inwards */
    // result.normal *= float(!isinf(result.t));
    return;
}


void worldRayIntersection(
    in  Sphere objects[2], 
    in  Ray ray, 
    out SphereRayIntersectionResult result
) {    
    SphereRayIntersectionResult curr_result, min_result;
    vec2 t_limits = vec2(0.001f, c_infinity);


    min_result.t      = c_infinity;
    min_result.normal = vec3(0.0f);
    for(int i = 0; i < 2; ++i)
    {
        intersection(ray, objects[i], t_limits, curr_result);
        // if(isinf(curr_result.t)) 
        //     continue; /* considering we don't have hundreds of objects, this should be fine without the conditional */

        
        if(curr_result.t < t_limits.y) {
            t_limits.y = curr_result.t;
            min_result = curr_result;
        }
    }
    result = min_result;
}


vec3 defaultRayColor(in Ray ray)
{
    vec3 unit = normalize(ray.dir);
    float t = 0.5f * (unit.y + 1.0f);
    
    return mix(
        vec3(1.0f, 1.0f, 1.0f),
        vec3(0.5f, 0.7f, 1.0f),
        t
    );
}



vec3 CalculatePixelColorDiffuse(in CameraTransform camera, in Sphere objects[2], in vec2 texelCoord)
{
    SphereRayIntersectionResult possibleHit;
    Ray cameraRayAtUV;
    vec3 returnedColor;
    uint mulHalf = 0;
    int  i       = 0;
    bool cont    = true;


    cameraRayAtUV = cameraGetRay(camera, camera.position, texelCoord);
    for(; i < u_recurseDepth && cont; ++i)
    {
        worldRayIntersection(objects, cameraRayAtUV, possibleHit);
        cont = !isinf(possibleHit.t);
        if(cont) {
            ++mulHalf;
            cameraRayAtUV.origin = rayAt(cameraRayAtUV, possibleHit.t);
            // cameraRayAtUV.dir    = possibleHit.normal + simpleRandUnitSphere(texelCoord, i); /* fake lambertian */
            /* true lambertian */
            cameraRayAtUV.dir = simpleRandUnitSphere(texelCoord, i);
            cameraRayAtUV.dir *= mix(-1.0f, 1.0f, dot(cameraRayAtUV.dir, possibleHit.normal) > 0);
        }
    }
    returnedColor = mix(
        defaultRayColor(cameraRayAtUV),
        vec3(0.0f),
        bvec3(i == u_recurseDepth)
    );
    return pow(0.5f, mulHalf) * returnedColor;
}





vec3 CalculatePixelColor(
    in CameraTransform camera, 
    in Sphere          objects[2], 
    in vec2            texelCoord
) {
    SphereRayIntersectionResult possibleHit;
    vec3 outColor = vec3(0.0f);
    Ray  cameraRayAtUV;
    vec2 currTexel;
    const float pixel_samples_inv = 1.0f / float(u_samplesPpx);


    /* for(uint sampleIdx = 0; sampleIdx < 1; ++sampleIdx) {} */
    for(uint sampleIdx = 0; sampleIdx < u_samplesPpx; ++sampleIdx) {

        // currTexel = texelCoord;
        currTexel = texelCoord + simpleRandUnitSphere(texelCoord, sampleIdx).xz * pixel_samples_inv * pixel_samples_inv;
        outColor += CalculatePixelColorDiffuse(camera, objects, currTexel);
    }


    outColor *= pixel_samples_inv; /* Get Average over All Samples */
    return outColor;
}


void main()
{
    /* Image Output Coordinates (pixel uv coord) */
    ivec2 texelCoord  = ivec2(gl_GlobalInvocationID.xy);
    vec2  texelCoordf = vec2(texelCoord) / vec2(gl_NumWorkGroups.xy);


    /* Output screen data */
    ivec2 windowSize  = imageSize(imageOut);
    float aspectRatio = float(windowSize.x) / float(windowSize.y);

    /* intermediates for calculations */
    vec3 finalColor = vec3(0.0f);


    // if(texelCoord.y + texelCoord.x * windowSize.x >= windowSize.x * windowSize.y) {
    //     return;
    // }

    CameraTransform camera = CameraTransform( /* in reality this would change its data on a resize of the window, which will be updated in the ssbo. */
        vec3(0.0f, 0.0f, 0.0f),         /* Position */
        vec2(aspectRatio * 2.0f, 2.0f), /* Viewport Width, height */
        1.0f,                           /* focal length */
        0                               /* reserved */
    );


    Sphere objects[2] = {
        Sphere(vec4(0.0f, 0.0f,    -1.0f, 0.5f  )),
        Sphere(vec4(0.0f, -100.5f, -1.0f, 100.0f))
    };


    texelCoord  = ivec2(gl_GlobalInvocationID.xy);
    texelCoordf = vec2(gl_GlobalInvocationID.xy) / vec2(gl_NumWorkGroups.xy * gl_WorkGroupSize.xy);
    finalColor = CalculatePixelColor(camera, objects, texelCoordf);
    finalColor = pow(finalColor, vec3(1.0f/2.2f));
    imageStore(imageOut, texelCoord, vec4(finalColor, 1.0f));
    return;
}