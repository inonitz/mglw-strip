#version 460 core
layout(local_size_x =   5, local_size_y =   5, local_size_z =   5) in;
layout(rgba32f, binding = 1) writeonly restrict uniform image2D imageOut;

layout(location = 1) uniform float u_dt;
layout(location = 2) uniform float u_rand;
layout(location = 3) uniform int u_samplesPpx;
layout(location = 4) uniform int u_recurseDepth;


struct Ray
{
    vec3 origin;
    vec3 dir;
};
struct Sphere
{ 
    vec4 pos_radius;
};
struct Material 
{
    vec4 data; 
};
struct CameraTransform
{
    vec3  position;
    vec2  viewport;
    float focal_length; /* Distance from camera origin to camera Screen */
    uint  reserved;
};
struct CameraTransformV2
{
    mat4 invView;
    mat4 invProj;
    vec3 origin;
};

layout(std430, binding=1) readonly buffer SceneData
{
    // CameraTransform sceneCameraTransform;
    CameraTransformV2 sceneCameraTransform;
    uint            sceneObjMaxLength;
    uint            sceneObjCurrLength;
    uint            reserved0[2];
    Sphere          sceneObject[];
};


layout(std430, binding=2) readonly buffer SceneMaterialBuffer
{
    Material materials[];
};


layout(std430, binding=3) readonly buffer SceneObjectToMaterialBuffer
{
    // /*
    //     format:
    //     u8  materialType;
    //     u8  reserved;
    //     u16 indexInMaterialSSBO; (materials[])
    // */
    uint objectToMaterial[];
};


layout(std140, binding=5) uniform SceneBlock { /* Migrate from SSBO to UBOs using this Struct */
    mat4 cameraInvView;
    mat4 cameraInvProj;
    vec3 cameraOrigin;
    uint activeObjects;
    uint activeMaterials;
    uint reserved1[2];
    Sphere   objects[450];          /* length = activeObjects   */
    Material materials[450];        /* length = activeMaterials */
    uint     objectToMaterial[450]; /* length = activeObjects   */
    /* because UBOs can be at-most 16KiB according to the spec, this guarantees 450 Objects & materials AT MOST */
};




const float c_infinity = 1. / 0.;
const float c_pi         = 3.14159265358979323846264338327950288;


float toRadians(float degrees) { return degrees * c_pi / 180.0f; }


float random( vec2 p )
{
    const vec2 r = vec2(23.1406926327792690, 2.6651441426902251);
    return fract( cos( mod( 123456789., 1e-7 + 256. * dot(p,r) ) ) );  
}

float uintToNormFloat(uint m) { 
    return uintBitsToFloat((m & 0x007FFFFFu) | 0x3F800000u ) - 1.0f; 
}

float random_norm(vec2 p) {
    return uintToNormFloat(floatBitsToUint(random(p)));
}

vec3 simpleRandUnitSphere(in vec2 texelCoord, uint sampleNum)
{
    vec3 r3 = vec3(
        random(  vec2(u_rand, random(texelCoord)       )),
        random(  vec2(u_rand, random(vec2(sampleNum))  )), 
        0
    );
    r3.z = random(r3.xy);
    return normalize(r3);
}


vec3 rayAt(in Ray ray, in float t) { return ray.origin + ray.dir * t; }

vec3 reflectRay(in vec3 ray_dir, in vec3 normal)
{
    return ray_dir - 2 * dot(ray_dir, normal) * normal;
}

vec3 refractRay(in vec3 ray, in vec3 normal, in float lambda)
{
	// /* lambda = eta / eta_prime */
	vec3 r_p, r_l;
	r_p = lambda * (ray - dot(ray, normal) * normal);
	r_l = sqrt( 1.0f - normal * dot(r_p, r_p) );
	return r_p - r_l;
}

float reflectance(in float cos_angle, in float refraction_idx)
{
    float r = (1 - refraction_idx) / (1 + refraction_idx);
    r *= r;
    return r + (1.0f - r) * pow( (1.0f - cos_angle), 5 ); 
}

bvec3 near_zero(in vec3 vec)
{
    return lessThan(abs(vec), vec3(1e-8));
}




struct SphereRayIntersectionResult
{
    float t;
    vec3  normal;
    uint  objectIndex;
};


void intersection(
    in  Ray    R, 
    in  Sphere S, 
    in  vec2   t_bounds, 
    out SphereRayIntersectionResult result
) {
    float a, b, ac, discrim;
    vec3 tmp;
    vec2 coef;


    tmp = R.origin - S.pos_radius.xyz;
    b = -1.0f * dot(R.dir, tmp); /* calculate -b */
    a = dot(R.dir, R.dir);
    ac = dot(tmp, tmp) - S.pos_radius.w * S.pos_radius.w;

    b  *= (1.0f / a);
    ac *= (1.0f / a);
    discrim = b * b - ac;

    result.t = float(discrim < 0.0f) * c_infinity;
    if(isinf(result.t))
        return;


    coef = vec2(
        b + sqrt(discrim),
        b - sqrt(discrim)
    );
    coef = mix(vec2(c_infinity), coef, 
        bvec2(
            t_bounds.x < coef.x && coef.x < t_bounds.y,
            t_bounds.x < coef.y && coef.y < t_bounds.y
        )
    );
    result.t = min(coef.x, coef.y);
    if(isinf(result.t))
        return;


    result.normal  = rayAt(R, result.t) - S.pos_radius.xyz;
    result.normal *= (1.0f / S.pos_radius.w);
    result.normal *= mix(-1.0f, 1.0f, dot(R.dir, result.normal) < 0.0f); /* set proper direction if vector is outwards/inwards */
    // result.normal *= float(!isinf(result.t));
    return;
}


void worldRayIntersection(
    in  Ray ray, 
    out SphereRayIntersectionResult result
) {    
    SphereRayIntersectionResult curr_result, min_result;
    vec2 t_limits = vec2(0.001f, c_infinity);


    min_result.t      = c_infinity;
    min_result.normal = vec3(0.0f);
    min_result.objectIndex = 0;
    for(int i = 0; i < sceneObjCurrLength; ++i)
    {
        intersection(ray, sceneObject[i], t_limits, curr_result);
        // if(isinf(curr_result.t)) 
        //     continue; /* considering we don't have hundreds of sceneObject, this should be fine without the conditional */

        
        if(curr_result.t < t_limits.y) {
            t_limits.y = curr_result.t;
            min_result = curr_result;
            min_result.objectIndex = i; /* objectIndex isn't relevant to the intersection function */
        }
    }
    result = min_result;
}


vec3 defaultRayColor(in Ray ray)
{
    vec3 unit = normalize(ray.dir);
    float t = 0.5f * (unit.y + 1.0f);
    
    return mix(
        vec3(1.0f, 1.0f, 1.0f),
        vec3(0.5f, 0.7f, 1.0f),
        t
    );
}




vec3 CalculatePixelColorMaterial(in vec2 texelCoord, in Ray cameraRay)
{
    SphereRayIntersectionResult possibleHit;
    Ray  cameraRayAtUV;
    vec3 attenuatedColor = vec3(1.0f);
    vec3 unitRay, randRay, operRay;
    vec4 selectedMaterialData;
    uint selectedMaterial;
    int  i       = 0;
    bool cont    = true, shouldRefract = true;
    float refract_ratio, cost, sint;


    cameraRayAtUV = cameraRay;
    for(; i < u_recurseDepth && cont; ++i)
    {
        worldRayIntersection(cameraRayAtUV, possibleHit);
        cont = !isinf(possibleHit.t);
        if(cont) {
            selectedMaterial     = objectToMaterial[ possibleHit.objectIndex ];
            selectedMaterialData = materials[ selectedMaterial >> 16 ].data;
            unitRay = normalize(cameraRayAtUV.dir);
            randRay = simpleRandUnitSphere(texelCoord, i);


            cameraRayAtUV.origin = rayAt(cameraRayAtUV, possibleHit.t);
            switch(selectedMaterial & 0xFF) {
                case 0: // LAMBERTIAN
                    operRay = possibleHit.normal + randRay;
                    if(all(near_zero(operRay)))
                        operRay = possibleHit.normal;

                    cameraRayAtUV.dir = operRay;
                    attenuatedColor *= selectedMaterialData.xyz;
                break;
                case 1: // METAL - if w component is non-zero, then metal is fuzzy
                    operRay = reflectRay(unitRay, possibleHit.normal);
                    cameraRayAtUV.dir = operRay + selectedMaterialData.w * randRay;
                    cont = dot(operRay, possibleHit.normal) > 0.0f;
                    attenuatedColor *= mix( vec3(0.0f), selectedMaterialData.xyz, bvec3(cont) );
                break;
                case 3: // DIELECTRIC
                cost = dot(unitRay, possibleHit.normal);
                refract_ratio = selectedMaterialData.w;
                refract_ratio = mix(refract_ratio, 1.0f/refract_ratio, cost > 0.0f);
                sint = sqrt(1 - cost * cost);

                shouldRefract = refract_ratio * sint > 1.0f;
                shouldRefract = shouldRefract || ( reflectance(cost, refract_ratio) > randRay.y );
                if(shouldRefract) {
                    cameraRayAtUV.dir = reflectRay(unitRay, possibleHit.normal);
                } else {
                    cameraRayAtUV.dir = refractRay(unitRay, possibleHit.normal, refract_ratio);
                }
                // cameraRayAtUV.dir = mix(
                //     refractRay(unitRay, possibleHit.normal, refract_ratio),
                //     reflectRay(unitRay, possibleHit.normal),
                //     bvec3(shouldRefract)
                // );
                break;
            }
        }
    }
    if(i == u_recurseDepth) {
        return vec3(0.0f);
    }
    return attenuatedColor * defaultRayColor(cameraRayAtUV);
}





vec3 CalculatePixelColor(in vec2 texelCoord) 
{
    SphereRayIntersectionResult possibleHit;
    vec3 outColor = vec3(0.0f);
    vec2 currTexel;
    vec4 texelCameraRayDir;
    Ray  texelRay;
    const float pixel_samples_inv = 1.0f / float(u_samplesPpx);


    texelRay.origin = sceneCameraTransform.origin;
    for(uint sampleIdx = 0; sampleIdx < u_samplesPpx; ++sampleIdx) {
        currTexel = texelCoord + simpleRandUnitSphere(texelCoord, sampleIdx).xz * pixel_samples_inv * pixel_samples_inv;

        /* Find out later if its worth pre-computing these vectors on the cpu with threads, or rather creating another compute pass for these. */
        texelCameraRayDir = vec4(2.0f * currTexel - 1.0f, 1.0f, 1.0f);
        texelCameraRayDir = sceneCameraTransform.invProj * texelCameraRayDir;
        texelCameraRayDir = vec4(normalize(texelCameraRayDir.xyz / texelCameraRayDir.w), 0.0f);
        texelCameraRayDir = sceneCameraTransform.invView * texelCameraRayDir;
        texelRay.dir = texelCameraRayDir.xyz;

        outColor += CalculatePixelColorMaterial(texelCoord, texelRay);
    }

    outColor *= pixel_samples_inv; /* Get Average over All Samples */
    return outColor;
}


void main()
{
    /* intermediates for calculations */
    vec3 finalColor = vec3(0.0f);

    /* Image Output Coordinates (pixel uv coord) */
    ivec2 texelCoord  = ivec2(gl_GlobalInvocationID.xy);
    vec2  texelCoordf = vec2(texelCoord) / vec2(gl_NumWorkGroups.xy * gl_WorkGroupSize.xy); 

    finalColor = pow( /* gamma correction */
        CalculatePixelColor(texelCoordf),
        vec3(0.45454545453f)
    );
    imageStore(imageOut, texelCoord, vec4(finalColor, 1.0f));
    return;
}
